{"version":3,"file":"index.esm.js","sources":["../../src/classes/Util.ts","../../src/constants/common.ts","../../src/classes/Encrypter.ts","../../src/classes/Decrypter.ts","../../src/classes/KeyGenerator.ts"],"sourcesContent":["// Imports\nimport childProcess from \"child_process\";\nimport crypto from \"crypto\";\n\nexport default abstract class Util {\n  /**\n   * @description Converts the given string to base64.\n   * @param string The string to be converted.\n   * @returns The base64 encoded string.\n   */\n  public static base64ToUtf8(string: string): string {\n    return Buffer.from(string, \"base64\").toString(\"utf-8\");\n  }\n\n  /**\n   * @description Converts the given string to base64.\n   * @param string The string to be converted.\n   * @returns The base64 encoded string.\n   */\n  public static utf8ToBase64(string: string): string {\n    return Buffer.from(string, \"utf-8\").toString(\"base64\");\n  }\n\n  /**\n   * @description Parses the key by encoding.\n   * @param key The key to be parsed.\n   * @returns The parsed key.\n   */\n  public static parseKeyByEncoding(key: string): string {\n    const utf8Regex = /-*(BEGIN|END)\\s\\w*\\s(PUBLIC|PRIVATE)\\sKEY-*/;\n    return utf8Regex.test(key) ? key : this.base64ToUtf8(key);\n  }\n\n  /**\n   * @description Retrieves the repository URL from the git configuration.\n   * @returns The repository URL.\n   */\n  public static getRepoUrl(): string {\n    try {\n      return childProcess.execSync(\"git config --get remote.origin.url\").toString().trim();\n    } catch {\n      throw new Error(\"Please execute from a valid git repository.\");\n    }\n  }\n\n  /**\n   * @description Unifies the repository URL into a consistent hash format.\n   * @param url The repository URL.\n   * @returns The hashed URL.\n   */\n  public static unifyRepoUrl(url: string): string {\n    const httpsRegex = /https?:\\/\\/.+/;\n    const sshRegex = /git@.*:.+/;\n\n    if (httpsRegex.test(url)) {\n      return this.unifyHTTPUrl(url);\n    } else if (sshRegex.test(url)) {\n      return this.unifySSHUrl(url);\n    } else {\n      throw new Error(\"Repo URL is not valid.\");\n    }\n  }\n\n  /**\n   * @description Unifies the HTTP repository URL into a consistent hash format.\n   * @param url The repository URL.\n   * @returns The hashed URL.\n   */\n  public static unifyHTTPUrl(url: string): string {\n    const [host, account, repo] = url.replace(/https?:\\/\\//, \"\").split(\"/\");\n    return this.hashHostAccountAndRepo(host, account, repo.replace(/\\.git$/, \"\"));\n  }\n\n  /**\n   * @description Unifies the SSH repository URL into a consistent hash format.\n   * @param url The repository URL.\n   * @returns The hashed URL.\n   */\n  public static unifySSHUrl(url: string): string {\n    const [hostAccount, repo] = url.replace(\"git@\", \"\").split(\":\");\n    const [host, account] = hostAccount.split(\"/\");\n    return this.hashHostAccountAndRepo(host, account, repo.replace(/\\.git$/, \"\"));\n  }\n\n  /**\n   * @description Hashes the host, account, and repository into a consistent format.\n   * @param host The repository host.\n   * @param account The repository account.\n   * @param repo The repository name.\n   * @returns The hashed host, account, and repository.\n   */\n  public static hashHostAccountAndRepo(host: string, account: string, repo: string): string {\n    return crypto.createHash(\"sha256\").update(`${host}${account}${repo}`).digest(\"hex\");\n  }\n\n  /**\n   * @description Converts the given string to an array of strings if not yet an array.\n   * @param data The string or array of strings.\n   * @returns The array of strings.\n   */\n  public static convertStringToArray(data: string | Array<string>): Array<string> {\n    if (typeof data === \"string\") {\n      data = [data];\n    }\n    return data;\n  }\n}\n","export const PUBLIC_KEY_NAME = \"public.key\";\nexport const PRIVATE_KEY_NAME = \"private.key\";\nexport const STATIC_PASSWORD = \"QMATE_STATIC\";\n\nexport const ALGORITHM = \"aes-256-cbc\";\n\nexport const DIGEST = \"sha512\";\nexport const SALT = \"72hdh393987f0hdc\";\nexport const IV = \"203efccd80e94d9f\";\nexport const ITERATIONS = 100000;\nexport const KEY_LENGTH = 32;\n\nexport const KEY_TYPE = \"rsa\";\nexport const KEY_EXPORT_TYPE = \"pkcs1\";\nexport const KEY_EXPORT_FORMAT = \"pem\";\n","// Imports\nimport fs from \"fs\";\nimport path from \"path\";\nimport crypto from \"crypto\";\n\nimport Util from \"./Util\";\n\n// Types\nimport { EncodedData, EncryptionOptions, PrintOptions, PublicKey } from \"../types/common\";\n\n// Constants\nimport { ALGORITHM, DIGEST, ITERATIONS, IV, KEY_LENGTH, PUBLIC_KEY_NAME, SALT, STATIC_PASSWORD } from \"../constants/common\";\n\nexport default abstract class Encrypter {\n  // ========================== Public functions ==========================\n  /**\n   * @description Retrieves public keys from the file system and encrypts data for all of them.\n   * @param data Data to be encrypted.\n   * @param encryptionOptions Encryption options.\n   */\n  public static encryptDataForAvailableKeys(data: string, encryptionOptions: EncryptionOptions, printOptions: PrintOptions): Array<EncodedData> {\n    if (printOptions?.printInput) {\n      this._printInput(data, encryptionOptions);\n    }\n\n    const publicKeys = this._retrievePublicKeys();\n    const encryptedData = this.encryptDataForMultipleKeys(data, encryptionOptions, publicKeys);\n\n    if (printOptions?.printOutput) {\n      this._printOutput(encryptedData);\n    }\n\n    return encryptedData;\n  }\n\n  /**\n   * @description Encrypts data for all passed public keys.\n   * @param data Data to be encrypted.\n   * @param encryptionOptions Encryption options.\n   * @param publicKeys Public keys for encryption.\n   */\n  public static encryptDataForMultipleKeys(data: string, encryptionOptions: EncryptionOptions, publicKeys: PublicKey[]): Array<EncodedData> {\n    const encodedDataAggregated: Array<EncodedData> = [];\n\n    data = encryptionOptions.useBase64Input ? Util.base64ToUtf8(data) : data;\n\n    for (const pk of publicKeys) {\n      const encryptedData = this._encryptData(data, pk.key, encryptionOptions);\n\n      const encodedData = encryptionOptions.useBase64Output ? Util.utf8ToBase64(encryptedData) : encryptedData;\n\n      encodedDataAggregated.push({ root: pk.root, encodedData });\n    }\n\n    return encodedDataAggregated;\n  }\n\n  // ========================== Private functions ==========================\n  /**\n   * @description Retrieves the public keys from the file system.\n   * @returns An array containing public key objects.\n   */\n  private static _retrievePublicKeys(): PublicKey[] {\n    const publicKeys: PublicKey[] = [];\n\n    try {\n      const publicKey = fs.readFileSync(path.resolve(process.cwd(), PUBLIC_KEY_NAME), \"utf8\");\n      publicKeys.push({ root: \"cwd\", key: publicKey });\n    } catch (error) {\n      // Do nothing\n    }\n\n    try {\n      const publicKey = fs.readFileSync(path.resolve(__dirname, \"../keys\", PUBLIC_KEY_NAME), \"utf8\");\n      publicKeys.push({ root: \"qmate\", key: publicKey });\n    } catch (error) {\n      // Do nothing\n    }\n\n    if (publicKeys.length < 1) {\n      throw new Error(\"Encryption failed. No public key found.\");\n    }\n\n    return publicKeys;\n  }\n\n  /**\n   * @description Encrypts the given data with the provided public key and options.\n   * @param data Data to be encrypted.\n   * @param publicKey Public key for encryption.\n   * @param options Encryption options.\n   * @returns The encrypted data.\n   */\n  private static _encryptData(data: string, publicKey: string, options: EncryptionOptions): string {\n    try {\n      const encryptedDataByKey = crypto.publicEncrypt(\n        {\n          key: Util.parseKeyByEncoding(publicKey),\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n          oaepHash: \"sha256\"\n        },\n        Buffer.from(data)\n      );\n\n      return this._encryptDataWithPassword(encryptedDataByKey.toString(\"base64\"), options);\n    } catch (error) {\n      throw new Error(`Encryption failed: ${error}`);\n    }\n  }\n\n  /**\n   * @description Encrypts data using AES-256-CBC encryption and PBKDF2 key derivation. The key is derived from the repo URL or a static password.\n   * @param data Data to be encrypted.\n   * @param options Encryption options.\n   * @returns The AES encrypted data.\n   */\n  private static _encryptDataWithPassword(data: string, options: EncryptionOptions): string {\n    let key: Buffer;\n\n    if (options.includeRepoUrl) {\n      const repoUrl = Util.getRepoUrl();\n      const repoUrlContractHashed = Util.unifyRepoUrl(repoUrl);\n      key = crypto.pbkdf2Sync(repoUrlContractHashed, SALT, ITERATIONS, KEY_LENGTH, DIGEST);\n    } else {\n      key = crypto.pbkdf2Sync(STATIC_PASSWORD, SALT, ITERATIONS, KEY_LENGTH, DIGEST);\n    }\n\n    const cipher = crypto.createCipheriv(ALGORITHM, key, IV);\n    let encryptedData = cipher.update(data, \"utf-8\", \"hex\");\n    encryptedData += cipher.final(\"hex\");\n\n    return encryptedData;\n  }\n\n  /**\n   * @description Prints the input options and data to the console.\n   * @param options Encryption options.\n   * @param data Data to be encrypted.\n   */\n  private static _printInput(data: string, options: EncryptionOptions): void {\n    console.log(\"\\n===========INPUT==========================================================\");\n\n    if (options.includeRepoUrl || options.useBase64Output || options.useBase64Input) {\n      console.log(\"Options:\");\n\n      if (options.includeRepoUrl) {\n        console.log(\"\\x1b[33m - Using repo URL in key derivation.\\x1b[0m\");\n      }\n      if (options.useBase64Input) {\n        console.log(\"\\x1b[33m - Input data is processed as base64 format.\\x1b[0m\");\n      }\n      if (options.useBase64Output) {\n        console.log(\"\\x1b[33m - Output data is displayed in base64 format.\\x1b[0m\");\n      }\n\n      console.log(\"\");\n    }\n\n    console.log(`Input Data: ${data}`);\n    console.log(\"==========================================================================\\n\");\n  }\n\n  /**\n   * @description Prints the output data and metadata to the console for multiple pieces of data.\n   * @param encodedDataList An array of encoded data objects containing root and encodedData.\n   */\n  private static _printOutput(encodedDataList: Array<EncodedData>): void {\n    console.log(\"\\n===========OUTPUT=========================================================\");\n    console.log(`Processing Info:`);\n\n    // Iterate through the array and print details for each entry\n    encodedDataList.forEach(({ root, encodedData }) => {\n      const rootMessage = root === \"cwd\" ? \"current working directory\" : \"qmate module\";\n\n      console.log(`\\x1b[33m - Public key is used from ${rootMessage}.\\x1b[0m\\n`);\n      console.log(\"Encrypted Data ⬎\");\n      console.log(`\\x1b[32m${encodedData}\\x1b[0m\\n`);\n    });\n\n    console.log(\"==========================================================================\");\n  }\n}\n","// Imports\nimport fs from \"fs\";\nimport path from \"path\";\nimport crypto from \"crypto\";\n\nimport Util from \"./Util\";\n\n// Constants\nimport { ALGORITHM, DIGEST, ITERATIONS, IV, KEY_LENGTH, PRIVATE_KEY_NAME, SALT, STATIC_PASSWORD } from \"../constants/common\";\n\n// Types\nimport { DecryptionOptions, PrintOptions, SecureData } from \"../types/common\";\n\nexport default abstract class Decrypter {\n  // ========================== Public functions ==========================\n  /**\n   * @description Retrieves the private key from the file system and decrypts data using it.\n   * @param data Data to be decrypted.\n   * @param decryptionOptions Decryption options.\n   * @returns Decrypted data.\n   */\n  public static decryptDataForAvailableKey(data: SecureData, decryptionOptions: DecryptionOptions, printOptions: PrintOptions): string {\n    if (printOptions?.printInput) {\n      this._printInput(data, decryptionOptions);\n    }\n\n    const privateKey = this.retrievePrivateKey(path.resolve(__dirname, \"../../../..\"));\n    const decryptedData = this.decryptData(data, privateKey, decryptionOptions);\n\n    if (printOptions?.printOutput) {\n      this._printOutput(decryptedData);\n    }\n\n    return decryptedData;\n  }\n\n  /**\n   * @description Decrypts data using the passed private key.\n   * @param data Data to be decrypted. Can either be as single value or array of values for different keys.\n   * @param privateKey Private key.\n   * @param options Decryption options.\n   * @returns Decrypted data.\n   */\n  public static decryptData(data: SecureData, privateKey: string, options: DecryptionOptions): string {\n    data = Util.convertStringToArray(data);\n\n    let decryptedDataByKey: any;\n    let decryptError: any;\n\n    for (const d of data) {\n      try {\n        const dataEncoded = options.useBase64Input ? Util.base64ToUtf8(d) : d;\n        const decryptedDataByRepoName = Buffer.from(this._decryptDataWithPassword(dataEncoded, options), \"base64\");\n\n        decryptedDataByKey = crypto.privateDecrypt(\n          {\n            key: Util.parseKeyByEncoding(privateKey),\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n            oaepHash: \"sha256\"\n          },\n          decryptedDataByRepoName\n        );\n      } catch (error) {\n        decryptError = error;\n      }\n    }\n\n    if (decryptedDataByKey) {\n      return options.useBase64Output ? Util.utf8ToBase64(decryptedDataByKey.toString()) : decryptedDataByKey.toString();\n    } else {\n      throw new Error(decryptError);\n    }\n  }\n\n  /**\n   * @description Retrieves the private key from the file system.\n   * @param dirname Directory name.\n   * @returns Private key.\n   */\n  public static retrievePrivateKey(dirname: string): string {\n    let privateKey;\n\n    try {\n      privateKey = fs.readFileSync(path.resolve(process.cwd(), PRIVATE_KEY_NAME), \"utf8\");\n    } catch (error) {\n      if (process.env.QMATE_PRIVATE_KEY) {\n        privateKey = process.env.QMATE_PRIVATE_KEY;\n        privateKey = privateKey.replace(/\\\\n/gm, \"\\n\");\n        privateKey = privateKey.replace(/\\\\s/gm, \" \");\n      } else {\n        try {\n          privateKey = fs.readFileSync(path.resolve(dirname, PRIVATE_KEY_NAME), \"utf8\");\n        } catch (error) {\n          throw new Error(`No private key found: ${error}`);\n        }\n      }\n    }\n\n    process.env.QMATE_PRIVATE_KEY = \"\";\n\n    return privateKey;\n  }\n\n  // ========================== Private functions ==========================\n  /**\n   * @description Decrypts data using a password.\n   * @param data Data to be decrypted.\n   * @returns Decrypted data.\n   */\n  private static _decryptDataWithPassword(data: string, options: DecryptionOptions): string {\n    let secretKey: Buffer;\n\n    if (options.includeRepoUrl) {\n      const repoUrl = Util.getRepoUrl();\n      const repoUrlContractHashed = Util.unifyRepoUrl(repoUrl);\n      secretKey = crypto.pbkdf2Sync(repoUrlContractHashed, SALT, ITERATIONS, KEY_LENGTH, DIGEST);\n    } else {\n      secretKey = crypto.pbkdf2Sync(STATIC_PASSWORD, SALT, ITERATIONS, KEY_LENGTH, DIGEST);\n    }\n\n    try {\n      const decipher = crypto.createDecipheriv(ALGORITHM, secretKey, IV);\n      let decryptedData = decipher.update(data, \"hex\", \"utf8\");\n      decryptedData += decipher.final(\"utf8\");\n      return decryptedData;\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new Error(error.message);\n      } else {\n        throw new Error(\"Unknown error\");\n      }\n    }\n  }\n\n  /**\n   * @description Prints the input options and data to the console.\n   * @param options Decryption options.\n   * @param data Data to be encrypted.\n   */\n  private static _printInput(data: SecureData, options: DecryptionOptions): void {\n    console.log(\"\\n===========INPUT==========================================================\");\n\n    if (options.includeRepoUrl || options.useBase64Input || options.useBase64Output) {\n      console.log(\"Options:\");\n\n      if (options.includeRepoUrl) {\n        console.log(\"\\x1b[33m - Using repo URL in key derivation.\\x1b[0m\");\n      }\n      if (options.useBase64Input) {\n        console.log(\"\\x1b[33m - Input data is processed as base64 format.\\x1b[0m\");\n      }\n      if (options.useBase64Output) {\n        console.log(\"\\x1b[33m - Output data is displayed in base64 format.\\x1b[0m\");\n      }\n\n      console.log(\"\");\n    }\n\n    if (data instanceof Array) {\n      console.log(\"Input Data:\");\n      console.log(\"\\x1b[33mMultiple data entries found. Trying to decrypt the data with the first key matching one of the entries.\\x1b[0m\");\n    }\n\n    console.log(\"==========================================================================\\n\");\n  }\n\n  /**\n   * @description Prints the decrypted data.\n   * @param decryptedData Decrypted data.\n   */\n  private static _printOutput(decryptedData: string): void {\n    console.log(\"\\n===========OUTPUT=========================================================\");\n    console.log(\"Decrypted Data ⬎\");\n    console.log(`\\x1b[32m${decryptedData}\\x1b[0m\\n`);\n    console.log(\"==========================================================================\");\n  }\n}\n","// Imports\nimport crypto from \"crypto\";\n\n// Types\nimport { KeyGenerationOptions } from \"../types/common\";\n\n// Constants\nimport { KEY_EXPORT_FORMAT, KEY_EXPORT_TYPE, KEY_TYPE } from \"../constants/common\";\n\nexport default abstract class KeyGenerator {\n  // ========================== Public functions ==========================\n  /**\n   * @description Generates a key pair and prints it to the console.\n   * @param options Key generation options.\n   */\n  public static generateKeyPair(options: KeyGenerationOptions): void {\n    this._printInput(options);\n\n    const { publicKey, privateKey } = crypto.generateKeyPairSync(KEY_TYPE, { modulusLength: 2048 });\n\n    const publicKeyExported = publicKey.export({ type: KEY_EXPORT_TYPE, format: KEY_EXPORT_FORMAT });\n    const privateKeyExported = privateKey.export({ type: KEY_EXPORT_TYPE, format: KEY_EXPORT_FORMAT });\n\n    const publicKeyFormatted = options.useBase64Encoding ? Buffer.from(publicKeyExported as string, \"utf8\").toString(\"base64\") : publicKeyExported;\n    const privateKeyFormatted = options.useBase64Encoding ? Buffer.from(privateKeyExported as string, \"utf8\").toString(\"base64\") : privateKeyExported;\n\n    this._printOutput(publicKeyFormatted, privateKeyFormatted);\n  }\n\n  // ========================== Private functions ==========================\n  /**\n   * @description Prints the input options to the console.\n   * @param options Key generation options.\n   */\n  private static _printInput(options: KeyGenerationOptions): void {\n    if (options.useBase64Encoding) {\n      console.log(\"\\n===========OPTIONS==========================================================\");\n\n      if (options.useBase64Encoding) {\n        console.log(\"\\x1b[33m - Output data is displayed in base64 format.\\x1b[0m\");\n      }\n      console.log(\"==========================================================================\");\n    }\n  }\n\n  /**\n   * @description Prints the generated key pair to the console.\n   * @param publicKey The generated public key.\n   * @param privateKey The generated private key.\n   */\n  private static _printOutput(publicKey: string | Buffer, privateKey: string | Buffer): void {\n    console.log(\"\\n===========OUTPUT=========================================================\");\n\n    console.log(\"Public Key ⬎\");\n    console.log(`\\x1b[32m${publicKey}\\x1b[0m\\n`);\n    console.log(\"Private Key ⬎\");\n    console.log(`\\x1b[33m${privateKey}\\x1b[0m`);\n\n    console.log(\"==========================================================================\");\n  }\n}\n"],"names":["Util","base64ToUtf8","string","Buffer","from","toString","utf8ToBase64","parseKeyByEncoding","key","test","this","getRepoUrl","childProcess","execSync","trim","Error","unifyRepoUrl","url","unifyHTTPUrl","unifySSHUrl","host","account","repo","replace","split","hashHostAccountAndRepo","hostAccount","crypto","createHash","update","digest","convertStringToArray","data","PUBLIC_KEY_NAME","PRIVATE_KEY_NAME","STATIC_PASSWORD","ALGORITHM","DIGEST","SALT","IV","ITERATIONS","KEY_EXPORT_TYPE","Encrypter","encryptDataForAvailableKeys","encryptionOptions","printOptions","printInput","_printInput","publicKeys","_retrievePublicKeys","encryptedData","encryptDataForMultipleKeys","printOutput","_printOutput","encodedDataAggregated","useBase64Input","pk","_encryptData","encodedData","useBase64Output","push","root","publicKey","fs","readFileSync","path","resolve","process","cwd","error","__dirname","length","options","encryptedDataByKey","publicEncrypt","padding","constants","RSA_PKCS1_OAEP_PADDING","oaepHash","_encryptDataWithPassword","includeRepoUrl","repoUrl","repoUrlContractHashed","pbkdf2Sync","cipher","createCipheriv","final","console","log","encodedDataList","forEach","rootMessage","Decrypter","decryptDataForAvailableKey","decryptionOptions","privateKey","retrievePrivateKey","decryptedData","decryptData","decryptedDataByKey","decryptError","d","dataEncoded","decryptedDataByRepoName","_decryptDataWithPassword","privateDecrypt","dirname","env","QMATE_PRIVATE_KEY","secretKey","decipher","createDecipheriv","message","Array","KeyGenerator","generateKeyPair","generateKeyPairSync","modulusLength","publicKeyExported","export","type","format","privateKeyExported","publicKeyFormatted","useBase64Encoding","privateKeyFormatted"],"mappings":"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"}