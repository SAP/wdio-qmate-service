import t from"fs";import e from"path";import o from"crypto";import r from"child_process";class s{static base64ToUtf8(t){return Buffer.from(t,"base64").toString("utf-8")}static utf8ToBase64(t){return Buffer.from(t,"utf-8").toString("base64")}static parseKeyByEncoding(t){return/-*(BEGIN|END)\s\w*\s(PUBLIC|PRIVATE)\sKEY-*/.test(t)?t:this.base64ToUtf8(t)}static getRepoUrl(){try{return r.execSync("git config --get remote.origin.url").toString().trim()}catch{throw new Error("Please execute from a valid git repository.")}}static unifyRepoUrl(t){if(/https?:\/\/.+/.test(t))return this.unifyHTTPUrl(t);if(/git@.*:.+/.test(t))return this.unifySSHUrl(t);throw new Error("Repo URL is not valid.")}static unifyHTTPUrl(t){const[e,o,r]=t.replace(/https?:\/\//,"").split("/");return this.hashHostAccountAndRepo(e,o,r.replace(/\.git$/,""))}static unifySSHUrl(t){const[e,o]=t.replace("git@","").split(":"),[r,s]=e.split("/");return this.hashHostAccountAndRepo(r,s,o.replace(/\.git$/,""))}static hashHostAccountAndRepo(t,e,r){return o.createHash("sha256").update(`${t}${e}${r}`).digest("hex")}static convertStringToArray(t){return"string"==typeof t&&(t=[t]),t}}const n="public.key",a="private.key",c="QMATE_STATIC",i="aes-256-cbc",l="sha512",p="72hdh393987f0hdc",u="203efccd80e94d9f",y=1e5,f="pkcs1";class d{static encryptDataForAvailableKeys(t,e,o){o?.printInput&&this._printInput(t,e);const r=this._retrievePublicKeys(),s=this.encryptDataForMultipleKeys(t,e,r);return o?.printOutput&&this._printOutput(s),s}static encryptDataForMultipleKeys(t,e,o){const r=[];t=e.useBase64Input?s.base64ToUtf8(t):t;for(const n of o){const o=this._encryptData(t,n.key,e),a=e.useBase64Output?s.utf8ToBase64(o):o;r.push({root:n.root,encodedData:a})}return r}static _retrievePublicKeys(){const o=[];try{const r=t.readFileSync(e.resolve(process.cwd(),n),"utf8");o.push({root:"cwd",key:r})}catch(t){}try{const r=t.readFileSync(e.resolve(__dirname,"../keys",n),"utf8");o.push({root:"qmate",key:r})}catch(t){}if(o.length<1)throw new Error("Encryption failed. No public key found.");return o}static _encryptData(t,e,r){try{const n=o.publicEncrypt({key:s.parseKeyByEncoding(e),padding:o.constants.RSA_PKCS1_OAEP_PADDING,oaepHash:"sha256"},Buffer.from(t));return this._encryptDataWithPassword(n.toString("base64"),r)}catch(t){throw new Error(`Encryption failed: ${t}`)}}static _encryptDataWithPassword(t,e){let r;if(e.includeRepoUrl){const t=s.getRepoUrl(),e=s.unifyRepoUrl(t);r=o.pbkdf2Sync(e,p,y,32,l)}else r=o.pbkdf2Sync(c,p,y,32,l);const n=o.createCipheriv(i,r,u);let a=n.update(t,"utf-8","hex");return a+=n.final("hex"),a}static _printInput(t,e){console.log("\n===========INPUT=========================================================="),(e.includeRepoUrl||e.useBase64Output||e.useBase64Input)&&(console.log("Options:"),e.includeRepoUrl&&console.log("[33m - Using repo URL in key derivation.[0m"),e.useBase64Input&&console.log("[33m - Input data is processed as base64 format.[0m"),e.useBase64Output&&console.log("[33m - Output data is displayed in base64 format.[0m"),console.log("")),console.log(`Input Data: ${t}`),console.log("==========================================================================\n")}static _printOutput(t){console.log("\n===========OUTPUT========================================================="),console.log("Processing Info:"),t.forEach((({root:t,encodedData:e})=>{const o="cwd"===t?"current working directory":"qmate module";console.log(`[33m - Public key is used from ${o}.[0m\n`),console.log("Encrypted Data â¬Ž"),console.log(`[32m${e}[0m\n`)})),console.log("==========================================================================")}}class g{static decryptDataForAvailableKey(t,o,r){r?.printInput&&this._printInput(t,o);const s=this.retrievePrivateKey(e.resolve(__dirname,"../../../..")),n=this.decryptData(t,s,o);return r?.printOutput&&this._printOutput(n),n}static decryptData(t,e,r){let n,a;t=s.convertStringToArray(t);for(const c of t)try{const t=r.useBase64Input?s.base64ToUtf8(c):c,a=Buffer.from(this._decryptDataWithPassword(t,r),"base64");n=o.privateDecrypt({key:s.parseKeyByEncoding(e),padding:o.constants.RSA_PKCS1_OAEP_PADDING,oaepHash:"sha256"},a)}catch(t){a=t}if(n)return r.useBase64Output?s.utf8ToBase64(n.toString()):n.toString();throw new Error(a)}static retrievePrivateKey(o){let r;try{r=t.readFileSync(e.resolve(process.cwd(),a),"utf8")}catch(s){if(process.env.QMATE_PRIVATE_KEY)r=process.env.QMATE_PRIVATE_KEY,r=r.replace(/\\n/gm,"\n"),r=r.replace(/\\s/gm," ");else try{r=t.readFileSync(e.resolve(o,a),"utf8")}catch(t){throw new Error(`No private key found: ${t}`)}}return process.env.QMATE_PRIVATE_KEY="",r}static _decryptDataWithPassword(t,e){let r;if(e.includeRepoUrl){const t=s.getRepoUrl(),e=s.unifyRepoUrl(t);r=o.pbkdf2Sync(e,p,y,32,l)}else r=o.pbkdf2Sync(c,p,y,32,l);try{const e=o.createDecipheriv(i,r,u);let s=e.update(t,"hex","utf8");return s+=e.final("utf8"),s}catch(t){throw t instanceof Error?new Error(t.message):new Error("Unknown error")}}static _printInput(t,e){console.log("\n===========INPUT=========================================================="),(e.includeRepoUrl||e.useBase64Input||e.useBase64Output)&&(console.log("Options:"),e.includeRepoUrl&&console.log("[33m - Using repo URL in key derivation.[0m"),e.useBase64Input&&console.log("[33m - Input data is processed as base64 format.[0m"),e.useBase64Output&&console.log("[33m - Output data is displayed in base64 format.[0m"),console.log("")),t instanceof Array&&(console.log("Input Data:"),console.log("[33mMultiple data entries found. Trying to decrypt the data with the first key matching one of the entries.[0m")),console.log("==========================================================================\n")}static _printOutput(t){console.log("\n===========OUTPUT========================================================="),console.log("Decrypted Data â¬Ž"),console.log(`[32m${t}[0m\n`),console.log("==========================================================================")}}class h{static generateKeyPair(t){this._printInput(t);const{publicKey:e,privateKey:r}=o.generateKeyPairSync("rsa",{modulusLength:2048}),s=e.export({type:f,format:"pem"}),n=r.export({type:f,format:"pem"}),a=t.useBase64Encoding?Buffer.from(s,"utf8").toString("base64"):s,c=t.useBase64Encoding?Buffer.from(n,"utf8").toString("base64"):n;this._printOutput(a,c)}static _printInput(t){t.useBase64Encoding&&(console.log("\n===========OPTIONS=========================================================="),t.useBase64Encoding&&console.log("[33m - Output data is displayed in base64 format.[0m"),console.log("=========================================================================="))}static _printOutput(t,e){console.log("\n===========OUTPUT========================================================="),console.log("Public Key â¬Ž"),console.log(`[32m${t}[0m\n`),console.log("Private Key â¬Ž"),console.log(`[33m${e}[0m`),console.log("==========================================================================")}}export{g as Decrypter,d as Encrypter,h as KeyGenerator};
//# sourceMappingURL=index.esm.js.map
